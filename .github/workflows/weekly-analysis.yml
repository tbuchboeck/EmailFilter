name: Weekly Email Analysis

on:
  schedule:
    # Run every Sunday at 9:00 AM UTC
    - cron: '0 9 * * 0'
  workflow_dispatch:  # Allow manual trigger

permissions:
  issues: write
  contents: write
  pull-requests: write

jobs:
  analyze:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Run email analysis
        env:
          # Easy Name Account (Primary)
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          # Gmail Account
          GMAIL_USER: ${{ secrets.GMAIL_USER }}
          GMAIL_PASS: ${{ secrets.GMAIL_PASS }}
          # Wife's Easy Name Account (Optional)
          WIFE_EMAIL_USER: ${{ secrets.WIFE_EMAIL_USER }}
          WIFE_EMAIL_PASS: ${{ secrets.WIFE_EMAIL_PASS }}
        run: |
          python3 analyze_inbox.py > analysis_output.txt 2>&1 || true

      - name: Parse and format results
        id: parse
        run: |
          python3 .github/scripts/format_analysis.py analysis_output.txt > formatted_results.md

          # Check if there are unfiltered emails
          UNFILTERED_COUNT=$(grep -o "Ungefiltert:.*E-Mails" analysis_output.txt | grep -o "[0-9]*" | head -1 || echo "0")
          echo "unfiltered_count=$UNFILTERED_COUNT" >> $GITHUB_OUTPUT

          # Set issue title
          if [ "$UNFILTERED_COUNT" -eq "0" ]; then
            echo "issue_title=‚úÖ Weekly Email Analysis - All emails filtered!" >> $GITHUB_OUTPUT
          else
            echo "issue_title=üìß Weekly Email Analysis - $UNFILTERED_COUNT unfiltered emails" >> $GITHUB_OUTPUT
          fi

      - name: Apply rule suggestions automatically
        id: apply
        run: |
          echo "ü§ñ Automatically applying suggested rules..."
          python3 .github/scripts/apply_suggestions.py analysis_output.txt || true

          # Check if there are any changes
          if git diff --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No changes to commit (no new rules or all rules already exist)"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected - will create PR"
          fi

      - name: Create Pull Request with new rules
        if: steps.apply.outputs.has_changes == 'true'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create branch with date
          BRANCH_NAME="weekly-analysis/$(date +%Y-%m-%d)"
          git checkout -b "$BRANCH_NAME"

          # Show what changed
          echo "üìù Changes to commit:"
          git diff --stat

          # Commit changes
          git add email_rules_*.json
          COMMIT_DATE=$(date +%Y-%m-%d)
          git commit -m "Add email rules from weekly analysis $COMMIT_DATE" \
                     -m "Automatically generated from weekly email analysis." \
                     -m "- Applied suggested rules to appropriate config files" \
                     -m "- Rules are ready for review and merge"

          # Push to remote
          echo "üöÄ Pushing branch: $BRANCH_NAME"
          git push -u origin "$BRANCH_NAME"

          # Store branch name for PR creation
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Create Pull Request
        id: create_pr
        if: steps.apply.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = process.env.BRANCH_NAME;
            const runDate = new Date().toISOString().split('T')[0];

            const prBody = "## ü§ñ Automated Weekly Email Analysis\n\n" +
              "This PR was automatically generated from the weekly email analysis on " + runDate + ".\n\n" +
              "### üìä What's included:\n" +
              "- New email filtering rules based on analysis of unfiltered emails\n" +
              "- Rules have been automatically added to the appropriate config files\n\n" +
              "### ‚úÖ Next steps:\n" +
              "1. **Review the rules** below to ensure they look correct\n" +
              "2. **Merge this PR** to apply the new rules\n" +
              "3. The rules will take effect on the next email sorting run\n\n" +
              "### üìù Changed files:\n" +
              "See the file diffs below for the exact rules that were added.\n\n" +
              "---\n\n" +
              "**Generated by:** Weekly Email Analysis Workflow\n" +
              "**Analysis date:** " + runDate;

            try {
              const pr = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: "üìß Add email rules from weekly analysis (" + runDate + ")",
                head: branchName,
                base: context.ref.replace('refs/heads/', ''),
                body: prBody,
                maintainer_can_modify: true
              });

              core.info("‚úÖ Created PR #" + pr.data.number + ": " + pr.data.html_url);

              // Store PR number and URL for the issue
              core.setOutput('pr_number', pr.data.number);
              core.setOutput('pr_url', pr.data.html_url);

              // Add label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['email-analysis', 'automated']
              });
            } catch (error) {
              if (error.message.includes('A pull request already exists')) {
                core.warning('‚ö†Ô∏è  A pull request already exists for this branch');
                core.setOutput('pr_number', '');
                core.setOutput('pr_url', '');
              } else {
                throw error;
              }
            }

      - name: Create or update issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const formattedResults = fs.readFileSync('formatted_results.md', 'utf8');
            const issueTitle = '${{ steps.parse.outputs.issue_title }}';
            const unfilteredCount = parseInt('${{ steps.parse.outputs.unfiltered_count }}');
            const hasChanges = '${{ steps.apply.outputs.has_changes }}' === 'true';

            // Search for existing open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['email-analysis'],
              per_page: 1
            });

            const runDate = new Date().toISOString().split('T')[0];
            const prNumber = '${{ steps.create_pr.outputs.pr_number }}';
            const prUrl = '${{ steps.create_pr.outputs.pr_url }}';

            // Determine the appropriate message based on state
            let howToSection;

            if (hasChanges && prUrl) {
              // State 1: Unfiltered emails + PR created
              howToSection = "## ‚úÖ Action Required\n\n" +
                "**ü§ñ Rules applied automatically!** A Pull Request has been created with the suggested rules.\n\n" +
                "### üëâ Next Steps:\n" +
                "**[Review and merge PR #" + prNumber + "](" + prUrl + ")**\n\n" +
                "The issue will automatically close when the PR is merged.\n\n" +
                "<details>\n" +
                "<summary>üìö Manual rule management (if needed)</summary>\n\n" +
                "### For legitimate senders:\n" +
                "1. Edit the appropriate email_rules_*.json file\n" +
                "2. Add rules manually to the \"rules\" array\n" +
                "3. Commit and push changes\n\n" +
                "### For spam:\n" +
                "1. Add the domain to spam_rules.json under \"blacklist_domains\"\n" +
                "2. Commit and push changes\n\n" +
                "</details>";
            } else if (unfilteredCount > 0) {
              // State 2: Unfiltered emails but no PR (rules might already exist or need manual creation)
              howToSection = "## ‚ÑπÔ∏è Manual Review Needed\n\n" +
                "There are unfiltered emails, but no automatic rules were created.\n\n" +
                "**Possible reasons:**\n" +
                "- Rules for these senders already exist\n" +
                "- Emails are from your own domain (review if they should be filtered)\n" +
                "- The automation couldn't determine the correct folder\n\n" +
                "### üëâ Next Steps:\n" +
                "1. **Review the unfiltered emails above**\n" +
                "2. **For legitimate emails:** Manually add rules to `email_rules_*.json`\n" +
                "3. **For spam:** Add domains to `spam_rules.json` blacklist\n" +
                "4. **For your own emails:** Consider if they should be filtered or stay in inbox\n\n" +
                "<details>\n" +
                "<summary>üìö How to add rules manually</summary>\n\n" +
                "### For legitimate senders:\n" +
                "Edit the appropriate `email_rules_*.json` file and add:\n" +
                "```json\n" +
                "{\n" +
                '  "name": "Folder Name",\n' +
                '  "folder": "INBOX/FolderName",\n' +
                '  "conditions": {\n' +
                '    "from_contains": ["sender@domain.com"]\n' +
                "  }\n" +
                "}\n" +
                "```\n\n" +
                "### For spam:\n" +
                "Edit `spam_rules.json` and add to blacklist:\n" +
                "```json\n" +
                '"blacklist_domains": [\n' +
                '  "spam-domain.com"\n' +
                "]\n" +
                "```\n" +
                "</details>";
            } else {
              // State 3: No unfiltered emails - all clear!
              howToSection = "## ‚úÖ All Clear!\n\n" +
                "All emails are properly filtered! Your inbox is clean. üéâ\n\n" +
                "This issue will be updated next Sunday with new analysis results.";
            }

            const issueBody = '# Weekly Email Analysis Report\n\n' +
              'Run date: ' + runDate + '\n\n' +
              formattedResults + '\n\n' +
              '---\n\n' +
              howToSection + '\n\n' +
              '---\n\n' +
              '**Next analysis:** Next Sunday at 9:00 AM UTC\n' +
              '**Manual trigger:** Go to Actions ‚Üí Weekly Email Analysis ‚Üí Run workflow';

            // Always create or update an issue (for weekly status reports)
            if (issues.data.length > 0) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                title: issueTitle,
                body: issueBody,
                labels: unfilteredCount > 0 ? ['email-analysis', 'needs-review'] : ['email-analysis'],
                state: 'open'
              });

              // Add a status comment
              const statusEmoji = unfilteredCount > 0 ? 'üìß' : '‚úÖ';
              const statusMsg = unfilteredCount > 0
                ? hasChanges
                  ? "Found " + unfilteredCount + " unfiltered email(s). A Pull Request has been created automatically! ü§ñ"
                  : "Found " + unfilteredCount + " unfiltered email(s). See updated report above."
                : 'All emails are filtered! Inbox is clean. üéâ';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: statusEmoji + " **Weekly Update:** " + runDate + "\n\n" + statusMsg
              });

              core.info("Updated issue #" + issues.data[0].number + " - " + unfilteredCount + " unfiltered email(s)");
            } else {
              // Create new issue (always, even if inbox is clean)
              const labels = unfilteredCount > 0
                ? ['email-analysis', 'needs-review']
                : ['email-analysis'];

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels
              });

              core.info("Created new issue #" + issue.data.number + " - " + unfilteredCount + " unfiltered email(s)");
            }
